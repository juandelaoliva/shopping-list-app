version: '3.3'

services:
  frontend:
    build: ./frontend
    restart: unless-stopped
    ports:
      # Mapeamos el puerto 8080 del anfitrión (Pi) al puerto 3000 del contenedor (frontend).
      # El router ya está redirigiendo el tráfico de internet del puerto 8080 al 8080 de nuestra Pi.
      - "8080:3000"

  # --- Servicios desactivados temporalmente ---
  # Los volveremos a activar uno por uno más adelante.

  # backend:
  #   build: ./backend
  #   restart: unless-stopped
  #   environment:
  #     DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
  #     NODE_ENV: production
  #   depends_on:
  #     - db

  # db:
  #   image: postgres:15
  #   restart: unless-stopped
  #   environment:
  #     POSTGRES_DB: ${POSTGRES_DB}
  #     POSTGRES_USER: ${POSTGRES_USER}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  #   volumes:
  #     - postgres_data:/var/lib/postgresql/data
  #     - ./backend/init.sql:/docker-entrypoint-initdb.d/init.sql

  # proxy:
  #   image: jc21/nginx-proxy-manager:latest
  #   restart: unless-stopped
  #   ports:
  #     # These ports are in format <host-port>:<container-port>
  #     - '8080:80' # Public HTTP Port
  #     - '8443:443' # Public HTTPS Port
  #     - '81:81' # Admin Web Port
  #   volumes:
  #     - proxy-data:/data
  #     - ./letsencrypt:/etc/letsencrypt

# Es necesario comentar los volúmenes para que Docker Compose no se queje de que no se usan.
# volumes:
#   postgres_data:
#   proxy-data: